[OOP]
현실 세계를 프로그래밍으로 옮겨와 현실 세계의 사물을 객체로 보고 ,그 객체로부터 개발하고자 하는 특징과 기능을 뽑아와 프로그래밍함. OOP로 코드를 작성하면 재사용성과 변형 가능성을 높일 수 있음


[OOP 5가지 설계 원칙]
1. SRP(Single Responsibility Principle, 단일 책임 원칙)
: 클래스는 단 하나의 목적을 가져야 하며, 클래스를 변경하는 이유는 단 하나의 이유여야 함

2. OCP(Open-Closed Principle, 개방 폐쇄 원칙)
: 클래스는 확장에 열려있되, 변경은 닫혀 있어야 함

3. LSP(Liskov Subtotution Principle, 리스코프 치환 원칙)
: 상위 타입의 객체를 하위 타입으로 바꿔도 프로그램은 일관성있게 동작

4. ISP(Interface Segregation Principle, 인터페이스 분리 원칙)
: 클라이언트는 이용하지 않는 메소드에 의존하지 않도록 인터페이스를 분리

5. DIP(Dependency Inversion Principle, 의존 역전 법칙)
: 클라이언트는 추상화(인터페이스)에 의존해야 하며, 구체화(구현된 클래스)에 의존 X


[절차지향 vs 객체지향]
1. 절차지향 프로그래밍
- 물이 위에서 아래로 흐르듯 순차적인 처리 프로그래밍
- EX) C언어
- 컴퓨터 처리구조와 유사하여 실행속도가 빠름
- 코드 순서가 바뀌면 결과가 달라질 수 있음

2. 객체지향
- 실제 세계의 사물들을 객체로 모델링하여 프로그래밍
- EX) JAVA
- 캡슐화, 상속, 다형성 등의 기법 이용. 다형성은 동일한 키보드의 키가 다른 역할을 하듯 하나의 메소드나 클래스가 다양한 방법으로 동작
- 절차지향 보다 느림


[RESTful API]
: REST(Representation State Transfer) API 는  HTTP 통신에서 어떤 차원에 대한 CRUD 요청을 Resource와 Method로 표현하여 특정 형태로 전달하는 방식
- Resource (자원, URI)
- Method (요청 방식, GET or POST)
- Representation of Resource (자원의 형태, JSON or XML)


[함수형 프로그래밍]
: immutable data, first class citizen인 함수. 부수 효과가 없는 순수 함수를 이용하여 프로그램을 만듦. 부수 효과가 없는 순수 함수란 데이터 값을 변형시키지 않으며 객체 필드를 설정하지 않는 것


[메모리 구조]
1. 코드 영역 : 실행할 프로그램의 코드가 저장되는 영역(텍스트 영역). 사용자가 프로그램 실행 명령을 내리면 OST가 HDD에서 실행 코드를 메모리로 올리고, CPU는 코드 영역에 저장된 명령어를 하나씩 처리

2. 데이터 영역 : 프로그램의 전역 변수(global)와 정적 변수(static)가 저장되는 영역. 프로그램의 시작과 함께 할당되며, 프로그램 종료시 소멸.

3. 힙 영역 : 프로그래머가 직접 관리할 수 있는 메모리 영역. 이 공간에 메모리를 할당 = 동적 할당. 낮은 주소에서 높은 주소로 메모리가 할당.

4. 스택 영역 : 함수 호출과 함께 할당. 지역 변수와 매개 변수가 저장되는 영역. 스택 영역에 저장되는 함수 호출 정보 = 스택 프레임. 스택 영역은 함수 호출 완료시 소멸. 높은 주소에서 낮은 주소로 메모리가 할당.


[Parameter vs Argument 차이]
- Parameter : 함수 선언 시 사용된 변수
- Argument : 함수 호출 시 parameter로 전달된 실제 값


[Call By Value vs Call By Reference 차이]
1. Call By Value
- 인자로 받은 값을 복사하여 처리
- Call By Value로 넘어온 값을 높여도 기존 값은 변화X
- 값을 복사하여 넘기기에 메모리 사용량 증대

2. Call By Reference
- 인자로 받은 값의 주소를 참조하여 직접 값에 영향을 줌
- 값을 복사하지 않고 직접 참조하기에 속도가 빠름
- 기존 값 변형 가능


[프레임워크 vs 라이브러리]
- 프레임워크 : 전체 흐름을 자체 제어 (사용자가 관리할 부분을 프레임워크에 넘겨 일을 줄임)
- 라이브러리 : 사용자가 흐름에 대한 제어를 하며 필요한 상황에 가져다가 쓸 수 있음


[병렬 처리 프레임워크]
1. Hadoop :
- HDFS(Hadoop Distributed File System)을 활용해 데이터를 교환
- 데이터가 여러 노드에 분산되어 저장. 데이터 손실 Low
- file I/O 를 기반으로 작동하기에 처리 속도가 느림

2. Spark :
- In-Memory 상에서 데이터를 교환 및 연상 수행
- 메모리를 써서 데이터를 처리하기에 Hadoop보다 속도가 약 100배 빠름
- 메모리 상에서 처리하기에 장애 발생시 응용 프로그램을 처음부터 다시 시작해야 함


[동기 vs 비동기]
1. 동기(Synchronous) 방식 :
- 요청을 보내고 실행을 마치면 다음 동작 처리
- 순서에 맞추어 진행하기에 제어
- 여러 요청을 동시 처리하지 못함
- EX) 콜센터 직원처럼 한 사람의 응대가 마쳐야만 다음 응대 가능

2. 비동기(Asynchronous) 방식 :
- 요청을 보내고 해당 동작의 처리 여부와 상관없이 다음 요청이 동작
- 이전 작업의 완료를 기다릴 필요가 없어 자원을 효율적으로 사용 가능
- 작업이 완료된 결과를 제어하기 어려움
- EX) 이메일. 누군가에게 이메일을 보냈을 때, 답변을 못 받아도 다른 메일을 보낼 수 있음


[SQL Injection]
SQL Injection 은 공격자가 악한 목적으로 구문을 삽입하여, 그가 원하는 SQL을 실행하도록 하는 웹해킹기법.


[Message Queue]
Queue 자료구조를 이용하여 데이터(메세지)를 관리하는 시스템, 비동기 통신 프로토콜을 제공하여 메세지를 빠르게 교환 가능. Producer가 Message를 Queue에 넣어두면, Consumer가 Message를 가져와 처리.


[Docker vs Kubernates]
1. Docker : 컨테이너 기반의 가상화 기술. 기존 OS를 가상화하였기에 Host OS 위에 Guest OS를 설치함. 무겁고 느리며 한계가 많음. Docker는 프로세스를 격리시킨 컨테이너를 통해 가상화함.

2. Keberanates :  Docker의 컨테이너를 관리


[Docker]
1. pros
- 쉽고 빠른 실행 환경 구축
- 하드웨어 자원 절감
- Docker 허브 등의 공유 환경 제공

2. cons
- 개발 초기의 오버헤드
- Linux 친화


[TDD (Test-Driven Development)]
매우 짧은 개발 사이클 반복에 의존하는 프로세스. 개발자는 요구 기능에 대한 testcase 및 코드를 작성 후, 테스트하며 상황에 맞게 리팩토링하는 테스트 주도 개발 방식.


[DDD (Domain-Driven Design)]
실세계에서 사건이 발생하는 집합인 Domain을 중심으로 설계.
EX) 쇼핑몰에서 손님이 주문하는 도메인, 점주 관리 도메인 등 여러 도메인이 상호 작용케 하는 도메인 주도 설계 방식. 도메인 주도 설계에서 각 도메인은 분리되어 있기에 MSA(MicroService Architecture) 를 적용하면 용이한 설계 가능. 구매자 기능 따로, 판매자 기능 따로 하듯 문맥에 따라 객체 역할이 변할 수 있음.


[MSA (Microservice Architecture)]
모든 시스템의 구성요소가 한 프로젝트에 통합된 Monolithic Architecture의 한계를 극복하고자 등장. MSA 1개 시스템을 독립 배포 가능한 각각의 서비스로 분할. 각 서비스는 RESTful API를 통해 데이터를 주고 받으며 1개의 큰 서비스를 구성.

1. pros :
- 일부 서비스에 장애가 발생해도 전체 서비스에 장애 발생 X
- 각 서비스는 서로 다른 언어와 프레임워크로 구성
- 서비스 확장 용이

2. cons :
- 서비스가 분리되어 있어, testing 및 transaction 처리가 어려움
- 서비스 간에 RESTful API 로 통신하기에 비용 발생
- 서비스 간 호출이 연속성을 가져 디버깅이 어려움


